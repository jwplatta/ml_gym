# Pandas

- Series - mix of a dictionary and numpy array
	- creation
	- retrieve values
		- retrieval using key
		- multi-item retrieval using keys
		- multi-item integer retrieval using integers
		- slicing using keys
		- slicing using integers
		- boolean masking get only positive values in a series
	- modify values
		- change multiple values at once
		- use boolean masking to change values
		- uses slicing to modify values
		- change index of a series
	- data analysis
		- scalar arithmetic is much easier with a series
		- using series.map to apply a function
		- series have many built in methods similar to numpy arrays, e.g. mean, min, std
	- alignment
		- adding series with different key sets together
		- add values while filling NaN values `ret1.add(ret3, fill_value=0)`
- DataFrames
	- retrieval
		- of a column or columns
		- of a row or rows
			- subsets
				- e.g. `df.loc['row', 'col_name']`
				- `loc` requires that the row sand columns that you select are present in the dataframe you are selecting on
			- slicing
			- boolean masks
			- avoiding using the loc method `df[df['AAPL'] < 0]`
	- modification
		- change a specific entry `df.loc['20201203','TSLA']=0.03`
		- entire column
		- boolean masking to set values
		-
- Data Exploration
	- `df.applymap` - applies element wise
	- `df.apply` - applies to each column
	- built in `df.corr()` and `df.cov()` and `df.corrwith(series_x)`
	- multiplying a dataframe by a series (across columns and rows)
- Missing Data
	- counting isnull and notnull on series and dataframes
	- remove missing data `ser[ser.notnull()]` or `ser.dropna()`
		- drop rows
		- rules dropping rows, e.g. `df.dropna(how='all')`, `df.dropna(thresh=3)`, `df.dropna(axis=1, thresh=3)`
	- filling missing data
		- `ser.fillna(0)` - fill with average, default value, forward fill
	- pandas function auto exclude `NaN`
- Reindexing
	- `ser.reindex(['TSLA','LULU','AAPL','MSFT'])`
	- `ser.drop`
		- drop a row
		- drop a column, e.g. `df.drop('TSLA', axis=1)`
- Sorting
	- series
		- `ser.sort_index()`
		- `ser.sort_values()`
	- dataframes
		- can also sort columns `df.sort_index(axis=1, ascending=False)`
		- group by sorting
- Plotting
	- `df['X'].plot(title='example plot')`
	- for all columns `df.plot(title='example plot')`
	- bar graphs `df.plot(kind='bar', title='example bar graph')`
	- scatter plots
	- historgrams
	- heatmaps using Seaborn `sns.heatmap(df.corr(), annot=True)` - most common use case is correlation
- categorical data
	- e.g. sectors are categorical data
	- unique values
		- `ser.unique()`
		- `ser.value_counts()`
	- mask for identify inclusion `mask = ser.isin(['Financials', 'Tech'])`
	- dummy variables `pd.get_dummies(ser)` - useful if you're running multi-variate regression and need indicator variables
- reading and writing files
	- csv, excel, pickle files
	- `df.to_csv('df_example.csv',index_label='Date')`
	- `from_csv=pd.read_csv('df_example.csv')`
	- `from_csv.set_index('Date')`
	- `df.to_pickle('df_example.pk')`
	- `pd.read_pickle('df_example.pk')`
- multi-indexing - when you want to carry around multiple predictor variables on a universe of stocks through time
	- multi-index dataframes
		- create multi-index rows `multi = pd.concat(data)`
		- create multi-index columns `multi = pd.concat(data, axis=1)`
	- multi-index series
		- `ser.unstack(level=0)` - converts the multi-index series into a dataframe
	- `multi.swaplevel(0,1,1)`, `multi.swaplevel(0,1,1).sort_index(1)`
	- sum across groups `multi.sum(axis=1, level=0)`
- timeseries
	- pandas timestamp object `pd.to_datetime('2011-01-07')`
	- convert back to string `dt.strftime('%Y%m%d')`
	- shifting timestamps `dt + pd.tseries.offsets.Day()` or `dt + pd.tseries.offsets.BDay()`
	- roll forward or roll back
		- `pd.tseries.offsets.MonthEnd().rollforward(dt)`
		- `pd.tseries.offsets.MonthEnd().rollback(dt)`
	- time deltas
	- `pd.DatetimeIndex(dates)`
	- `pd.date_range(dt1, dt2, freq='D')`, other frequencies include 'M', 'min'
	- resample
		- `df.resample('M').sum()` - month sum
		- 5 min max `df.resample('5min').max()`
		- close - `df.resample('5min').last()`
- group by, pivot, merge
	- `df.groupby('ticker').mean()`
	- group by multiple columns: `df.groupby(['sector', 'date']).mean()`
		- aggregate metric on a single column `df.groupby(['sector', 'date'])[['signal1']].mean()`
	- use group by with an arbitrary function
	- group by using indexes `df.grouby(level=0).mean()`
	- iterate over groups with `for key, val in df.groupby('section'): `
	- `dt.pivot_table(index='date',columns='ticker', values='signal1', aggfunc=np.mean)
	- merge / joining dataframes `df.merge(data2, left_on=['sector','date'], right_on=['sector', 'date'])`
- rolling - computing moving averages - `df.rolling(252, min_periods=1).mean()` where 252 is the window size
- quantiles - or buckets - `pd.qcut(series, 10, labels = False)`
	- `qcut.value_counts().sort_index()`
	- `df['AAPL'].groupby(qcut).describe()`
- shift - move forward the data
	- `df.shift()`
	- `df / df.shift() -1 ` - computes the return for each day